# Fraud Detector :credit_card: :male_detective:

В наши дни, електронните разплащания са гръбнакът на световната финансова система. Все по-често предпочитаме да пазаруваме онлайн, да плащаме с карта и да превеждаме пари по електронен път. Електронните парични потоци за съжаление все по-често стават и обект на посегателство от злонамерени агенти, които извършват различни видове измами, възползвайки се от пробиви в сигурността, кражба на лични данни, социално инженерство и други. Това е актуален и значим проблем, както за финансовите институции, така и за индивидуалните потребители като нас. По различни оценки, загубите от измами възлизат на около 5% от световния финансов оборот: повече от 6 трилиона долара годишно!

Това поражда необходимостта от разработването на сложни системи и алгоритми за откриване на измами, които надеждно да гарантират сигурността и доверието в електронните финансовите операции.

Откриването на измами (*fraud detection*) е свързано с анализ на риска и идентифицирането на *подозрителни* финансови транзакции: това са транзакции, чиито характеристики ги определят като "отклонения" (*outliers*), т.е. като значително различаващи се от останалите транзакции в един поток или набор от данни. Тези отклонения (*аномалии*) се откриват автоматично и задействат детайлното им разглеждане от човек.

Тази седмица ще приложим знанията си за работа с файлове, входно-изходни потоци, ламбда изрази и Java Stream API-то, за да създадем **Fraud Detector**, който ще изчислява риска, анализирайки финансови транзакции на потребители (акаунти). Анализът ще се базира на реален *dataset*, съдържащ данни за над 2,500 финансови транзакции, който е взет от [kaggle](https://www.kaggle.com/datasets/valakhorasani/bank-transaction-dataset-for-fraud-detection), онлайн платформата за machine learning и data science на Google. Понеже оригиналният dataset съдържа някои колони, които няма да ни трябват за задачата, сме ги премахнали, като може да свалите обработения файл от [тук](./resources/dataset.csv).

Всеки ред от файла съдържа информация за една транзакция, като полетата са разделени със запетая (CSV формат):

`TransactionID,AccountID,TransactionAmount,TransactionDate,Location,Channel`

## Transaction Analyzer

В пакета `bg.sofia.uni.fmi.mjt.frauddetector.analyzer` създайте клас `TransactionAnalyzerImpl`, който има публичен конструктор `TransactionAnalyzerImpl(Reader reader, List<Rule> rules)` и имплементира интерфейса `TransactionAnalyzer`

На конструктора се подава коректно създаден входен поток, от който може да се изчете dataset-a.
При извикване на конструктора с множество правила със сумарна тежест, различна от 1.0, хвърляйте `IllegalArgumentException`.

:point_right: Обърнете внимание, че dataset-ът съдържа заглавен ред, който трябва да пропуснете при изчитането му.

:point_right: Напомняне: когато сравнявате числа с плаваща запетая, не разчитайте на точно равенство, а работете с равенство с определена точност (делта). 

### Транзакции

Транзакциите се моделират от record-a `Transaction`, който има следните компоненти: `(String transactionID, String accountID, double transactionAmount, LocalDateTime transactionDate, String location, Channel channel)` и има публичен статичен factory метод със сигнатура

`public static Transaction of(String line)`,

който по даден низ, представляващ ред от dataset-a, връща `Transaction` обект.

### Канали

Транзакциите могат да се извършват по един от три вида канали: банкомат, онлайн и банков клон, описвани от следния enum:

```java
package bg.sofia.uni.fmi.mjt.frauddetector.transaction;

public enum Channel {
    ATM, ONLINE, BRANCH
}
```

## Правила за изчисляване на риска

Ще създадем множество правила, чрез които ще оценяваме риска на базата на аномалии в транзакциите на дадения акаунт. Всяко правило се характеризира с *праг*, който го задейства (прави приложимо) и относително *тегло*, с което участва в изчислението на риска. Теглото е число в интервала [0.0, 1.0], а сумата от теглата на всички правила трябва да е 1.0.

1. **FrequencyRule**: Оценява риска на базата на *честота на транзакциите*, т.е. броят им в определен времеви прозорец.
   - Праг: брой транзакции в рамките на времевия прозорец.

   Класът трябва да има публичен конструктор със сигнатура `FrequencyRule(int transactionCountThreshold, TemporalAmount timeWindow, double weight)`.

2. **LocationsRule**: Оценява риска на базата на броя различни *локации на транзакциите*.
   - Праг: брой различни локации, от които са осъществени транзакции.

   Класът трябва да има публичен конструктор със сигнатура `LocationsRule(int threshold, double weight)`.

3. **SmallTransactionsRule**: Оценява риска на базата на твърде голям брой транзакции на дребна сума.
   - Праг: брой транзакции на сума под определен размер.

   Класът трябва да има публичен конструктор със сигнатура `SmallTransactionsRule(int countThreshold, double amountThreshold, double weight)`.

4. **ZScoreRule**: Оценява риска въз основа на т.нар. *Z-score* на сумата на транзакциите, което е метрика за това, колко се различава сумата на транзакцията от средната стойност за дадения акаунт.
   - Праг: Z-score над определено число.

   Класът трябва да има публичен конструктор със сигнатура `ZScoreRule(double zScoreThreshold, double weight)`.

За да разберем z-score метриката, трябва да се запознаем с някои понятия от статистиката:

- *Нормално разпределение* (*Normal distribution*) на данните в един dataset означава, че повечето данни са концентрирани около средната стойност и са симетрични спрямо нея.

- *Дисперсия* (*Variance*) е мярка за "разпръснатостта" на стойностите в даден набор от данни, т.е. колко далеч от средната стойност стигат.

Дисперсията се изчислява по следната формула:

![Variance formula](../lecture/images/08.3-variance-formula.png)

където *μ* е средната стойност, т.е.

![Average value formula](../lecture/images/08.4-average-value-formula.png)
  
- *Стандартно отклонение* (*Standard deviation*) е една от основните мерки за оценка на разсейването или разпространението на стойностите в един набор от данни. То показва, колко далеч са отделните стойности от средната стойност на тези данни. Стандартното отклонение се пресмята като квадратния корен на дисперсията:

![Standard deviation formula](../lecture/images/08.5-standard-deviation-formula.png)

- *Z-score* е метрика за това, колко далеч е дадена стойност от средната стойност, но измерено в брой стандартни отклонения.

Формулата за изчисляване на z-score е следната:

![Z-score formula](../lecture/images/08.6-z-score-formula.png)

където:
- *x* е стойността на данната,
- *μ* е средната стойност,
- *σ* е стандартното отклонение.

Ако ви е любопитно, може да научите повече за [нормалното разпределение](https://www.mathsisfun.com/data/standard-normal-distribution.html), [стандартното отклонение и дисперсията](https://www.mathsisfun.com/data/standard-deviation.html) и [z-score-а](https://www.mathsisfun.com/definitions/z-score.html) - ще ви е полезно за курса по статистика.

Всички правила се намират в пакета `bg.sofia.uni.fmi.frauddetector.rule` и имплементират интерфейса `Rule`



